//Header for this file
#include "flatfileinterface.h"

//C System-Headers
#include <termios.h>  /* POSIX terminal control definitions */
#include <sys/ioctl.h>
#include <fcntl.h>//fopen(),fclose()
#include <unistd.h>//read(), write()
#include <stdio.h>

//C++ System headers
#include <vector>//vector
#include <string>//string
#include <fstream>//iss*
#include <chrono>// timing functions
#include <cmath>//sqrt, abs
#include <iostream>//cout
#include <typeinfo>//typeid
#include <algorithm> // transform, find
#include <functional> // plus/minus
#include <utility>//std::make_pair
#include <map>//std::map
#include <mutex>

//Boost Headers
#include <boost/algorithm/string.hpp>//split() and is_any_of for parsing .csv files
#include <boost/lexical_cast.hpp>//lexical cast (unsurprisingly)
#include <dirent.h>

//Miscellaneous Headers
#include <omp.h>//OpenMP pragmas

FlatFileReader::FlatFileReader(std::string dir_name) {

    std::vector<std::string> file_list = EnumerateFiles(dir_name, "SA_F");

    std::mutex guard;

    #pragma omp parallel for
    for ( uint i = 0 ; i < file_list.size() ; i ++) {

        guard.lock();
        raw_data_list.push_back( FastRead( file_list.at(i) ) );
        guard.unlock();
    }
}

FlatFileReader::~FlatFileReader() {
    raw_data_list.clear();
}

std::vector<std::string> FlatFileReader::EnumerateFiles(std::string dir_name, std::string sift_term) {

    DIR *dir;
    struct dirent *ent;
    const char* c_dir_name = dir_name.c_str();

    std::vector<std::string> file_names;

    if ((dir = opendir (c_dir_name)) != NULL) {

        while ((ent = readdir (dir)) != NULL) {

            std::string file_name = std::string (ent->d_name);

            if( file_name.find(sift_term) != std::string::npos ) {
                file_names.push_back( dir_name+file_name );
            }
        }

        return file_names;
        closedir (dir);
    } else {
        /* could not open directory */
        perror ("");
        return file_names;
    }
}

//boost::split seems to be fond of generating empty strings
//This function searches through a vector of strings generated by the boost::split function
//and erases any blank strings
inline void RemoveBlanks (std::vector<std::string> &strs) {
    strs.erase( std::remove( strs.begin(), strs.end(), "" ), strs.end() );
    strs.erase( std::remove( strs.begin(), strs.end(), "\n" ), strs.end() );
}

std::string FlatFileReader::FastRead( std::string file_name ) {
    const char* c_file_name = file_name.c_str();

    std::ifstream file_stream(c_file_name);
    std::stringstream buffer;
    buffer << file_stream.rdbuf();

    return buffer.str();
}

uint FlatFileReader::size(){
    return raw_data_list.size();
}

bool FlatFileReader::has(uint index){
    return (index <= raw_data_list.size())?true:false;
}

std::string FlatFileReader::at(uint index){
    return raw_data_list.at(index);
}

/*
void ConfigProcessor::LoadFromPresets(const char* presets_name) {

    std::ifstream t(presets_name);
    std::stringstream buffer;
    buffer << t.rdbuf();
    std::string total= buffer.str();

    std::vector<std::string> strs;
    boost::split(strs, total, boost::is_any_of("@"));

    std::vector<std::string> strs_2;
    std::vector<std::string> strs_3;

    std::vector<std::string> parent_names;

    std::vector<std::map<std::string,std::pair<std::string,int>>> pres_vec;

    RemoveBlanks(strs);

    for(const auto& val:strs) {
        boost::split(strs_2, val, boost::is_any_of("\n"));
        RemoveBlanks(strs_2);

        std::map<std::string,std::pair<std::string,int>> presets;

        for(const auto& val_2: strs_2) {

            boost::split(strs_3, val_2, boost::is_any_of(";"));
            RemoveBlanks(strs_3);

            if(strs_3.size()==1) {
                if(!strs_3[0].empty()) {
                    parent_names.push_back(strs_3[0]);
                }
            }

            if(strs_3.size()>=3) {
                std::string ctl_name=strs_3.at(0);
                std::string cid=strs_3.at(1);
                int value=boost::lexical_cast<int>(strs_3.at(2));

                std::pair<std::string,int> val=std::make_pair(cid,value);

                presets[ctl_name]=val;
            }
        }
        pres_vec.push_back(presets);
    }

    for(unsigned int i=0; i<parent_names.size(); i++) {
        pres[parent_names[i]]=pres_vec[i];
    }

    t.close();
}
*/
