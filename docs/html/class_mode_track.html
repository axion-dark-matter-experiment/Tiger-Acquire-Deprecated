<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Electric Tiger Control Code: ModeTrack Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Electric Tiger Control Code
   &#160;<span id="projectnumber">0.1</span>
   </div>
   <div id="projectbrief">Python files from Electric Tiger</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_mode_track.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="class_mode_track-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ModeTrack Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Base Class for mode tracking algorithims; designed to be wrapped with Swig and called from Python module.  
 <a href="class_mode_track.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="modetrack_8h_source.html">modetrack.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a53130b8d183a69b14d2ef47666d09385"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mode_track.html#a53130b8d183a69b14d2ef47666d09385">FromFile</a> (std::string config_name)</td></tr>
<tr class="memdesc:a53130b8d183a69b14d2ef47666d09385"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run mode tracking algorithim on previously saved data.  <a href="#a53130b8d183a69b14d2ef47666d09385">More...</a><br/></td></tr>
<tr class="separator:a53130b8d183a69b14d2ef47666d09385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa04491a2f3b4bb04fe6503757d416b73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mode_track.html#aa04491a2f3b4bb04fe6503757d416b73">SetBackground</a> (std::string background_str)</td></tr>
<tr class="memdesc:aa04491a2f3b4bb04fe6503757d416b73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set background data which will be subtracted from each measurement.  <a href="#aa04491a2f3b4bb04fe6503757d416b73">More...</a><br/></td></tr>
<tr class="separator:aa04491a2f3b4bb04fe6503757d416b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4ab8caa7ab71906390651cdd4c20c0c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mode_track.html#ac4ab8caa7ab71906390651cdd4c20c0c">GetPeaksGauss</a> (std::string data_str, int mode_number)</td></tr>
<tr class="memdesc:ac4ab8caa7ab71906390651cdd4c20c0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identify minima peaks in a list of power data using Gaussian filtering.  <a href="#ac4ab8caa7ab71906390651cdd4c20c0c">More...</a><br/></td></tr>
<tr class="separator:ac4ab8caa7ab71906390651cdd4c20c0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2158f2117f99a3aee6891bcc2126aa83"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mode_track.html#a2158f2117f99a3aee6891bcc2126aa83">GetPeaksBiLat</a> (std::string data_str, int mode_number)</td></tr>
<tr class="memdesc:a2158f2117f99a3aee6891bcc2126aa83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identify minima peaks in a list of power data using Bilateral filtering.  <a href="#a2158f2117f99a3aee6891bcc2126aa83">More...</a><br/></td></tr>
<tr class="separator:a2158f2117f99a3aee6891bcc2126aa83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ffe12b39a5d90b6ba7a25c0c66bea8d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mode_track.html#a8ffe12b39a5d90b6ba7a25c0c66bea8d">GetMaxPeak</a> (std::string data_str)</td></tr>
<tr class="memdesc:a8ffe12b39a5d90b6ba7a25c0c66bea8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a local maximum in a list of data.  <a href="#a8ffe12b39a5d90b6ba7a25c0c66bea8d">More...</a><br/></td></tr>
<tr class="separator:a8ffe12b39a5d90b6ba7a25c0c66bea8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99eeeb6757873474994a61dbd7e31e43"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a99eeeb6757873474994a61dbd7e31e43"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetLowerBound</b> (double frequency)</td></tr>
<tr class="separator:a99eeeb6757873474994a61dbd7e31e43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b7a1977d0cdacf2533581c82707e018"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7b7a1977d0cdacf2533581c82707e018"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetUpperBound</b> (double frequency)</td></tr>
<tr class="separator:a7b7a1977d0cdacf2533581c82707e018"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a2e778157cfd43504c969244a841c14de"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>Method</b> { <b>Gauss</b>, 
<b>BiLat</b>
 }</td></tr>
<tr class="separator:a2e778157cfd43504c969244a841c14de"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a4e0a0d9430910d77c067c0ee40110200"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mode_track.html#a4e0a0d9430910d77c067c0ee40110200">LoadFromConfig</a> (const char *config_name)</td></tr>
<tr class="memdesc:a4e0a0d9430910d77c067c0ee40110200"><td class="mdescLeft">&#160;</td><td class="mdescRight">opens file specified and loads values into enteries_strings  <a href="#a4e0a0d9430910d77c067c0ee40110200">More...</a><br/></td></tr>
<tr class="separator:a4e0a0d9430910d77c067c0ee40110200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a992935ab5c2bd97e824a88039238e07f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a992935ab5c2bd97e824a88039238e07f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mode_track.html#a992935ab5c2bd97e824a88039238e07f">CastToType</a> ()</td></tr>
<tr class="memdesc:a992935ab5c2bd97e824a88039238e07f"><td class="mdescLeft">&#160;</td><td class="mdescRight">casts each element in enteries_strings from a string to a double and loads into entries. <br/></td></tr>
<tr class="separator:a992935ab5c2bd97e824a88039238e07f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8461b01cf1c811aa7cf781fb9bb07f68"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mode_track.html#a8461b01cf1c811aa7cf781fb9bb07f68">Derivative</a> (std::vector&lt; double &gt; &amp;data_list)</td></tr>
<tr class="memdesc:a8461b01cf1c811aa7cf781fb9bb07f68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the the forth order approximation of the derivative.  <a href="#a8461b01cf1c811aa7cf781fb9bb07f68">More...</a><br/></td></tr>
<tr class="separator:a8461b01cf1c811aa7cf781fb9bb07f68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dccdca7cd909c332b5ed1e09118cd98"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mode_track.html#a5dccdca7cd909c332b5ed1e09118cd98">PopulateBestFitCurves</a> ()</td></tr>
<tr class="memdesc:a5dccdca7cd909c332b5ed1e09118cd98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load cubic spline coeffecients for modes 0 through 3.  <a href="#a5dccdca7cd909c332b5ed1e09118cd98">More...</a><br/></td></tr>
<tr class="separator:a5dccdca7cd909c332b5ed1e09118cd98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe43b234695b74e5c493acb08aec39b7"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mode_track.html#afe43b234695b74e5c493acb08aec39b7">StdDev</a> (std::vector&lt; double &gt; &amp;data_list)</td></tr>
<tr class="memdesc:afe43b234695b74e5c493acb08aec39b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the standard deviation of a list.  <a href="#afe43b234695b74e5c493acb08aec39b7">More...</a><br/></td></tr>
<tr class="separator:afe43b234695b74e5c493acb08aec39b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9749deca774e487cbcc694a56b226cd"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mode_track.html#ac9749deca774e487cbcc694a56b226cd">Normalize</a> (std::vector&lt; double &gt; &amp;data_list)</td></tr>
<tr class="memdesc:ac9749deca774e487cbcc694a56b226cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize a list of data w.r.t. to the L2 norm.  <a href="#ac9749deca774e487cbcc694a56b226cd">More...</a><br/></td></tr>
<tr class="separator:ac9749deca774e487cbcc694a56b226cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d08e12e9d882c875e6f7f4b8539f542"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mode_track.html#a8d08e12e9d882c875e6f7f4b8539f542">Convolve</a> (std::vector&lt; double &gt; &amp;data_list, std::vector&lt; double &gt; &amp;kernel)</td></tr>
<tr class="memdesc:a8d08e12e9d882c875e6f7f4b8539f542"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the 1D convolution of data_list with kernel.  <a href="#a8d08e12e9d882c875e6f7f4b8539f542">More...</a><br/></td></tr>
<tr class="separator:a8d08e12e9d882c875e6f7f4b8539f542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa315defc02162bed269fa981a01382b8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mode_track.html#aa315defc02162bed269fa981a01382b8">GaussBlur</a> (std::vector&lt; double &gt; &amp;data_list)</td></tr>
<tr class="memdesc:aa315defc02162bed269fa981a01382b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the convulution of data_list with a Gaussian kernel.  <a href="#aa315defc02162bed269fa981a01382b8">More...</a><br/></td></tr>
<tr class="separator:aa315defc02162bed269fa981a01382b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69dab14db20b8ffdcae63914fb2e0c83"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mode_track.html#a69dab14db20b8ffdcae63914fb2e0c83">FindPeaks</a> (std::vector&lt; double &gt; &amp;data_list, ModeTrack::Method method)</td></tr>
<tr class="memdesc:a69dab14db20b8ffdcae63914fb2e0c83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find minima peaks in a list.  <a href="#a69dab14db20b8ffdcae63914fb2e0c83">More...</a><br/></td></tr>
<tr class="separator:a69dab14db20b8ffdcae63914fb2e0c83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83776f06fac4ccff81ae76405dc5bee8"><td class="memItemLeft" align="right" valign="top">std::map&lt; uint, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mode_track.html#a83776f06fac4ccff81ae76405dc5bee8">CompareAndFill</a> (std::vector&lt; double &gt; &amp;peak_list, std::vector&lt; std::tuple&lt; double, double, double &gt; &gt; &amp;comparison_list)</td></tr>
<tr class="memdesc:a83776f06fac4ccff81ae76405dc5bee8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the position of each identified peak with estimated peak position.  <a href="#a83776f06fac4ccff81ae76405dc5bee8">More...</a><br/></td></tr>
<tr class="separator:a83776f06fac4ccff81ae76405dc5bee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7960f1ee58a1a420814843ca0f8c0ae4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mode_track.html#a7960f1ee58a1a420814843ca0f8c0ae4">GenerateSpline</a> (int mode_number, double length)</td></tr>
<tr class="memdesc:a7960f1ee58a1a420814843ca0f8c0ae4"><td class="mdescLeft">&#160;</td><td class="mdescRight">GenerateSpline.  <a href="#a7960f1ee58a1a420814843ca0f8c0ae4">More...</a><br/></td></tr>
<tr class="separator:a7960f1ee58a1a420814843ca0f8c0ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad69c546f3d3ac916b0f00c7aa2917903"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mode_track.html#ad69c546f3d3ac916b0f00c7aa2917903">GaussKernel</a> (int r)</td></tr>
<tr class="memdesc:ad69c546f3d3ac916b0f00c7aa2917903"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a Gaussian kernel of radius r and sigma = r/2 Kernel is generated by sampling Gaussian function with sigma = r/2 a total of r times.  <a href="#ad69c546f3d3ac916b0f00c7aa2917903">More...</a><br/></td></tr>
<tr class="separator:ad69c546f3d3ac916b0f00c7aa2917903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e59f0ed0b57daebd0d051d594faf1f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mode_track.html#a9e59f0ed0b57daebd0d051d594faf1f9">ParseString</a> (std::string data_str)</td></tr>
<tr class="memdesc:a9e59f0ed0b57daebd0d051d594faf1f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">ParseString.  <a href="#a9e59f0ed0b57daebd0d051d594faf1f9">More...</a><br/></td></tr>
<tr class="separator:a9e59f0ed0b57daebd0d051d594faf1f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb8bbf4d81e0333da7d176c1e475ceaa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abb8bbf4d81e0333da7d176c1e475ceaa"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>BilateralFilter</b> (std::vector&lt; double &gt; &amp;data_list, double sigma_s, double sigma_r)</td></tr>
<tr class="separator:abb8bbf4d81e0333da7d176c1e475ceaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0102fdc2d13318b65d2127e4733725c6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0102fdc2d13318b65d2127e4733725c6"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>FindMaxima</b> (std::vector&lt; double &gt; &amp;data_list)</td></tr>
<tr class="separator:a0102fdc2d13318b65d2127e4733725c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab5c7a6c9acd8478b93a4e943e67dcb3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aab5c7a6c9acd8478b93a4e943e67dcb3"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>GetPeaks</b> (std::string data_str, int mode_number, Method filter_method)</td></tr>
<tr class="separator:aab5c7a6c9acd8478b93a4e943e67dcb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac2fd6070522ecbfa7b2b2295416f72d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac2fd6070522ecbfa7b2b2295416f72d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>DebugSaveInfo</b> (std::vector&lt; double &gt; filtered_list, Method method)</td></tr>
<tr class="separator:aac2fd6070522ecbfa7b2b2295416f72d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad95e1bb9346109bcda61f25e9cc2cdc6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad95e1bb9346109bcda61f25e9cc2cdc6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>CheckBounds</b> (double frequency)</td></tr>
<tr class="separator:ad95e1bb9346109bcda61f25e9cc2cdc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:aa9b7a628197e5929e76a6bd9b7481650"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa9b7a628197e5929e76a6bd9b7481650"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>lower_bound</b> = 0.0f</td></tr>
<tr class="separator:aa9b7a628197e5929e76a6bd9b7481650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa26bb53ca89328131bd15be63db392b4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa26bb53ca89328131bd15be63db392b4"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>upper_bound</b> = 0.0f</td></tr>
<tr class="separator:aa26bb53ca89328131bd15be63db392b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac042e73bed483d080e48246d55318fa6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac042e73bed483d080e48246d55318fa6"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>max_search_radius</b> = 436.344</td></tr>
<tr class="separator:ac042e73bed483d080e48246d55318fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6acf61e6f22fdda9a696013b13b30304"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6acf61e6f22fdda9a696013b13b30304"></a>
std::vector&lt; std::tuple<br class="typebreak"/>
&lt; std::string, std::string, <br class="typebreak"/>
std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mode_track.html#a6acf61e6f22fdda9a696013b13b30304">entries_strings</a></td></tr>
<tr class="memdesc:a6acf61e6f22fdda9a696013b13b30304"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for raw entries loaded from config. file. Used by the function <a class="el" href="class_mode_track.html#a53130b8d183a69b14d2ef47666d09385" title="Run mode tracking algorithim on previously saved data. ">FromFile()</a> <br/></td></tr>
<tr class="separator:a6acf61e6f22fdda9a696013b13b30304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e854bd28c396015e5d723c05b638450"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1e854bd28c396015e5d723c05b638450"></a>
std::vector&lt; std::tuple<br class="typebreak"/>
&lt; double, double, double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mode_track.html#a1e854bd28c396015e5d723c05b638450">entries</a></td></tr>
<tr class="memdesc:a1e854bd28c396015e5d723c05b638450"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for data enteries converted from std::strings to doubles Used by the function <a class="el" href="class_mode_track.html#a53130b8d183a69b14d2ef47666d09385" title="Run mode tracking algorithim on previously saved data. ">FromFile()</a> <br/></td></tr>
<tr class="separator:a1e854bd28c396015e5d723c05b638450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02671d29adcf46f88c611194b7351f0b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a02671d29adcf46f88c611194b7351f0b"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mode_track.html#a02671d29adcf46f88c611194b7351f0b">background</a></td></tr>
<tr class="memdesc:a02671d29adcf46f88c611194b7351f0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Background data, to be subtracted off of main data set. <br/></td></tr>
<tr class="separator:a02671d29adcf46f88c611194b7351f0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af99ee8eb4ea41c82bb67243e597744d1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::tuple<br class="typebreak"/>
&lt; double, double, double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mode_track.html#af99ee8eb4ea41c82bb67243e597744d1">estimated_paths</a></td></tr>
<tr class="memdesc:af99ee8eb4ea41c82bb67243e597744d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">quadratic best-fit coeffecients for each of the four modes.  <a href="#af99ee8eb4ea41c82bb67243e597744d1">More...</a><br/></td></tr>
<tr class="separator:af99ee8eb4ea41c82bb67243e597744d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Base Class for mode tracking algorithims; designed to be wrapped with Swig and called from Python module. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a83776f06fac4ccff81ae76405dc5bee8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; uint, double &gt; ModeTrack::CompareAndFill </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>peak_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; double, double, double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>comparison_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare the position of each identified peak with estimated peak position. </p>
<p>Estimated peak positions are generated from old Reflection Map data. The distance -in frequency space- between each identified peak and each estimated peak is computed. Using these numbers the index of each identified peak is determined (by looking at the smallest frequency seperation). If duplicate peak indices are discovered the one with the smallest frequency seperation is used.</p>
<p>If it is found that any peaks have been missed, that is there is a gap between identified peak indices, the position of the missing peaks will be estimated using the <a class="el" href="class_mode_track.html#a7960f1ee58a1a420814843ca0f8c0ae4" title="GenerateSpline. ">GenerateSpline()</a> function. For example if peaks 0 and 3 were found, the position of peaks 1 and 2 would be estimated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">peak_list</td><td>List of peaks identified by <a class="el" href="class_mode_track.html#a69dab14db20b8ffdcae63914fb2e0c83" title="Find minima peaks in a list. ">FindPeaks()</a> functions </td></tr>
    <tr><td class="paramname">comparison_list</td><td>List of data triples generated by <a class="el" href="class_mode_track.html#a7960f1ee58a1a420814843ca0f8c0ae4" title="GenerateSpline. ">GenerateSpline()</a> function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Dictionary of identified peaks, with the format of </dd></dl>

</div>
</div>
<a class="anchor" id="a8d08e12e9d882c875e6f7f4b8539f542"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; ModeTrack::Convolve </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>kernel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the 1D convolution of data_list with kernel. </p>
<p>Note that edge effects are handeled by zero padding data_list</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data_list</td><td>List of data to be convolved with kernel </td></tr>
    <tr><td class="paramname">kernel</td><td>Convolution kernel, must be smaller than data_list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Convolution of data_list and kernel </dd></dl>

</div>
</div>
<a class="anchor" id="a8461b01cf1c811aa7cf781fb9bb07f68"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; ModeTrack::Derivative </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the the forth order approximation of the derivative. </p>
<p>Uses method <img class="formulaInl" alt="$ f'(n) \approx \frac{-f(n+2)+8*f(n+1)-8*f(n-1)+f(n-2)}{12} $" src="form_1.png"/> to approximate the derivative.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data_list</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a69dab14db20b8ffdcae63914fb2e0c83"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; ModeTrack::FindPeaks </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ModeTrack::Method&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find minima peaks in a list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data_list</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of peaks in the order in which they were found. Note that peak position will be given by indices with regard to the original list. </dd></dl>

</div>
</div>
<a class="anchor" id="a53130b8d183a69b14d2ef47666d09385"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModeTrack::FromFile </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>config_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run mode tracking algorithim on previously saved data. </p>
<p>This function is primarily used to test the effectiveness of the mode tracking scheme. It is not designed to be called while the experiment is running.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config_name</td><td>path to the file that should be searched </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa315defc02162bed269fa981a01382b8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; ModeTrack::GaussBlur </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the convulution of data_list with a Gaussian kernel. </p>
<p>The Gaussian kernel will have radius of 15 and sigma = 15/2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data_list</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ad69c546f3d3ac916b0f00c7aa2917903"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; ModeTrack::GaussKernel </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a Gaussian kernel of radius r and sigma = r/2 Kernel is generated by sampling Gaussian function with sigma = r/2 a total of r times. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>The radius of the generated kernel </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Gassian Kernel </dd></dl>

</div>
</div>
<a class="anchor" id="a7960f1ee58a1a420814843ca0f8c0ae4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double ModeTrack::GenerateSpline </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>GenerateSpline. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode_number</td><td></td></tr>
    <tr><td class="paramname">length</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a8ffe12b39a5d90b6ba7a25c0c66bea8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ModeTrack::GetMaxPeak </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>data_str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a local maximum in a list of data. </p>
<p>This method applies the same Gaussian Blur/Derivative filter combination that 'GetPeaks' uses, but does not make reference to the estimated peak positions. If multiple peaks are identified take the one with the highest overall value. This function is designed to be called when identifying peaks when looking at a transmission measurement.</p>
<dl class="section return"><dt>Returns</dt><dd>Frequency of maxima, if one is found. Otherwise return value will be 0. </dd></dl>

</div>
</div>
<a class="anchor" id="a2158f2117f99a3aee6891bcc2126aa83"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ModeTrack::GetPeaksBiLat </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>data_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode_number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identify minima peaks in a list of power data using Bilateral filtering. </p>
<p>This function is very similar to <a class="el" href="class_mode_track.html#ac4ab8caa7ab71906390651cdd4c20c0c" title="Identify minima peaks in a list of power data using Gaussian filtering. ">GetPeaksGauss()</a> except for the method that is used to filter data. This function makes use of a Bilateral filter for data pre-processing.</p>
<p>See <a href="https://users.cs.duke.edu/~tomasi/papers/tomasi/tomasiIccv98.pdf">https://users.cs.duke.edu/~tomasi/papers/tomasi/tomasiIccv98.pdf</a> for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data_str</td><td>string containing power data that should be searched through. Needs to be in the a list of values seperated by commas, eg "p1,p2,...,pn"</td></tr>
    <tr><td class="paramname">mode_number</td><td>Identify which mode should be tracked. Choices are 0,1,2 and 3.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The frequency of the requested mode in MHz. If the requested mode was not found a value of 0 will be returned. </dd></dl>

</div>
</div>
<a class="anchor" id="ac4ab8caa7ab71906390651cdd4c20c0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ModeTrack::GetPeaksGauss </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>data_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode_number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identify minima peaks in a list of power data using Gaussian filtering. </p>
<p>This function is designed to be called by the main control code during data taking. The main control program will collect reflection measurements and call this function to identify the position of the mode of desire.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data_str</td><td>string containing power data that should be searched through. Needs to be in the a list of values seperated by commas, eg "p1,p2,...,pn"</td></tr>
    <tr><td class="paramname">mode_number</td><td>Identify which mode should be tracked. Choices are 0,1,2 and 3.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The frequency of the requested mode in MHz. If the requested mode was not found a value of 0 will be returned. </dd></dl>

</div>
</div>
<a class="anchor" id="a4e0a0d9430910d77c067c0ee40110200"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ModeTrack::LoadFromConfig </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>config_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>opens file specified and loads values into enteries_strings </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config_name</td><td>path to file that the mode tracking algorithim should be run against, usually an old mode map or coupling map. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac9749deca774e487cbcc694a56b226cd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; ModeTrack::Normalize </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Normalize a list of data w.r.t. to the L2 norm. </p>
<p>That is for the list of the values <img class="formulaInl" alt="$ \{a_1,a_2...,a_i\}$" src="form_3.png"/> ensure that <img class="formulaInl" alt="$ \sqrt{\sum_{i=1}^n | a_i |^2} = 1 $" src="form_4.png"/> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data_list</td><td>The input list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Normalized list. Note that this allows the original list to go unaltered. </dd></dl>

</div>
</div>
<a class="anchor" id="a9e59f0ed0b57daebd0d051d594faf1f9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ModeTrack::ParseString </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>data_str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ParseString. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data_str</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5dccdca7cd909c332b5ed1e09118cd98"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ModeTrack::PopulateBestFitCurves </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load cubic spline coeffecients for modes 0 through 3. </p>
<p>These values were attained by examining an old mode map. </p>

</div>
</div>
<a class="anchor" id="aa04491a2f3b4bb04fe6503757d416b73"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModeTrack::SetBackground </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>background_str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set background data which will be subtracted from each measurement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">background_str</td><td>string of power values seperated by commas, eg "p1,p2,...,pn" </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afe43b234695b74e5c493acb08aec39b7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double ModeTrack::StdDev </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the standard deviation of a list. </p>
<p>Includes unbiasing via Bessel's correction, ie <img class="formulaInl" alt="$ \frac{n}{n-1} $" src="form_2.png"/></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data_list</td><td>Input data list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Standard deviation of list. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="af99ee8eb4ea41c82bb67243e597744d1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::tuple&lt;double,double,double&gt; &gt; ModeTrack::estimated_paths</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>quadratic best-fit coeffecients for each of the four modes. </p>
<p>format is <img class="formulaInl" alt="$ f(x) = a x^2+b x+c$" src="form_0.png"/> and tuple is populated with (a,b,c) first entry in vector corresponds to the first mode (ie mode 0) second entry corresponds to mode 1 etc. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/bephillips2/workspace/Electric_Tiger_Control_Code/<a class="el" href="modetrack_8h_source.html">modetrack.h</a></li>
<li>/home/bephillips2/workspace/Electric_Tiger_Control_Code/modetrack.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_mode_track.html">ModeTrack</a></li>
    <li class="footer">Generated on Tue Jul 26 2016 05:49:09 for Electric Tiger Control Code by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
